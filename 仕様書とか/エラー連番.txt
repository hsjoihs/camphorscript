全部のエラーに連番的な何かを振って、
その全てに対応するエラーファイルを作成しよう
なに、「ネタ切れ」だと？
失礼な、Base_Step2を完璧にする大切な作業じゃないか

--考察--
連番だと、後でエラーが増えた時に色々と面倒になるのは知っている
ということでそこを詳しく考察していこう
ParseErrorの内部にParseError2という型を作ろう
で、内部実装からHTMLマニュアルを自動生成したり、
コンパイラオプションからマニュアルが読めたりしたら嬉しいよね
連番は、内部では使う(全エラー網羅とかのとき)けどそれ以外では使わず、
追加は常に最後、削除はその番号を最後の要素で埋めるとかする
要するに、殆ど意味論的な要素は無い
じゃあ意味論的な要素はどうするか。
ディレクトリツリー的に表そう
例えばstep2/type/wrongcall/notypematch/funcとか
step2/fixity/wrongdef/conflictfixdef/operとか
step/エラーの種類/場所/詳細/(func|oper)とかどうだろう
何故この順番かというと、
1. typeとfixityの区別はverUpでも変わらない
2. callかdefかによってコードの位置は大きく変わる
3. funcかoperかは処理的に非常に似ている
つまり、「区別が絶対的」な順で行う
まあ数カ月後にどうせこの決断を後悔するんだろうけど(予言) -- 22:12 2014/08/04 (月)

--エラーリスト--
さーてどう表現するか
一番使いやすいのはHaskellソースコードだけどカスタマイズしにくいからな
その点物理ディレクトリなら操作しやすい
でもユーザがエラーいじることもないし、Haskellソースコードでいいかも -- 22:42 2014/08/04 (月)
ここからHTMLを自動生成 -- 5:20 2014/08/05 (火)
まあparsec内のsyntax errorには連番振れないけど仕方ないね -- 5:25 2014/08/05 (火)

--作成--
さて、ソースコード内ではどういうリテラルでエラーを表現したものか
案1 Step2 <\> Fixity <\> Wrongdef <\> ConflictFixDef <\> Operatorで<\>が$のalias -- 9:24 2014/08/07 (木)

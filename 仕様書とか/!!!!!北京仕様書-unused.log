| 一部はassert仕様書.txtに移転 |


---------------------Page 03---------------------
|      メモリ再利用最適化について語るページ     |
-------------------------------------------------
1. /*# MEMORY using c #*/ char e; って
   書けるようにしたい
2. 長くzero-ensuredされている変数を自動的に
   deleteして、必要時にまたcharしてもいいよね
3. 現行仕様「0に近いメモリから再利用」って
   場合によっては非合理的なんだよね。どうしよう。

   例                       | 案1:
                            |  最後に参照した
     空いてる    作業場所   |  メモリの
   _____________@@@@@@@@@@  |  最も近くから
                            |  探す
            ↓char q;       | 
                            | 案2:
   q  空いてる   作業場所   |  より一般性のある
   @____________@@@@@@@@@@  |  ScrambledEggを
                            |  考える
   往復のコストがかかる     | 
                            | 



---------------------Page 04---------------------
|         ScrambledEggについて語るページ        |
-------------------------------------------------
1. アルゴリズムの内容
  入力は「店の作成」「店の参照」「店の削除」の
  3種のクエリからなる。最初は0番地から始める。
  非負整数の番地に店を作成できる。店を作成または
  参照するときには、その番地に移動する必要がある。
  移動には番地の差に比例した時間を必要とする。
  所要時間が最短のとき、どの番地に店を作るべきか。
  なお、既に店があるところに重ねて店は作れない。

2. 使い方
 2-1. 変数を出来るだけ細分化
 2-2. 参照だけ取り出してScrambleEggする
 2-3. そのアドレスにallocateする

3. 実装
  実際の最適解を求めるのは私には無理だろう。よって
  粗い近似を考える。これをHalfScrambledEggと呼ぶ。

4. HalfScrambledEggの実装
  自分より先に作成された店を「先輩」と呼ぶ。自分が
  消失する直後までの店の中で、関わる「先輩」との
  関係を最適化する。
  …なんか教訓じみている



---------------------Page 05---------------------
|        様々な最適化を命名するページその1      |
-------------------------------------------------
1. 意義
  後にコンパイラオプションにするときに使える
  仕様書・ログ内でも使えそう。なお12字以内縛り。

2. 命名
 2-2. 加乗変換最適化
   内容: メモリを用いて大きい数の加減算を乗算化
   命名: incdectomult
 2-3. 旧式メモリ最適化
   内容: 0から順に空きアドレスを探しメモリを確保
   命名: naiverecycle
 2-4. メモリ細分最適化
   内容: メモリをなるべく早く解放しメモリ使用量を
         減らし、Scrambleしやすくする
   命名: memoryshred



---------------------Page 06---------------------
|        様々な最適化を命名するページその2      |
-------------------------------------------------
 2-5. メモリ半分最適化
   内容: HalfScrambledEggを実行する
   命名: halfscramble
 2-6. 新型メモリ最適化(妄想)
   内容: 未だ見ぬScrambledEggを実行する
   命名: scramble

3. 補足
  これらの否定は先頭にnoを付ける。
  ちなみにnomemoryshredはソース上でも、
  /*# MEMORY noshred #*/と書けば実現できる。
  さらに、 /*# MEMORY noshred a #*/と書けば、
  aはshredされない。
  現状ではdefaultは2-3だが、
  ゆくゆくは2-1 2-2 2-4 2-5にしたい



---------------------Page 07---------------------
|            warningについて語るページ          |
-------------------------------------------------

-Werror : Warningをエラーに

---------------------Page 08---------------------
|        具体的なwarningについて語るページ      |
-------------------------------------------------
1. zero-ensureされていないところのdelete, #using#
   [Crucial]
2. 未使用の変数 [Verbose]
3. #WARNING deprecated#な関数の使用 [Helpful]
4. コメント内コメント [Important]
5. 不明なpragma [Helpful]
6. pragmaのような何か ( /*# ～ */など) [Important]
7. #WARNING "～"#でuser-defined error [Helpful]
8. #WARNING crucial "～"#でレベル設定
9. func(a,b,c) { ～ } [Important]
   (セミコロンが抜けてないか？というwarning)

今のところはこんな感じでいいだろう
仕様増えればwarningも増えるはずで、
そもそもErrorにすべき時のほうが多いわけだし


---------------------Page 10---------------------
|         for文について語ろうとしたページ       |
-------------------------------------------------
1. 概説
  はい。ネタ切れですよネタ切れ。やったね。
  ということで新ダンジョン「for文」の解説。
2. 実装
  うーんいいのが思いつかない。
  前にも考えてたはずだし、例のblogにあった
  foldなどとともに出直すべきか
  まあ早くてもver0.8になる気がする
  ということで一旦保留

------------------Page 11上半分------------------
|         構造体について語るページ上半分        |
-------------------------------------------------
1. 概説
  これまた新ダンジョン「構造体」を遊んでいこう
2. 構文
  struct pairChar{char first, char second}
  pairChar a;  a.first = 1;  a.second = 2;
  clear(a.first); clear(a.second); 
  delete a; // all fields must be zero
3. 実装
  コンパイル時には変数をバラすだけでいいのだが、
  型の種類が増えるのでそれへの対応が必要。
4. その他
  構造体実装直後にtypedef実装の予定
  short型とか楽しみ

------------------Page 11下半分------------------
|    overflow optionについて語るページ上半分    |
-------------------------------------------------
-foverflowが指定されると、メモリが256でoverflow, 
underflowすることを前提として最適化される。
具体的には、大きい数の代入などが最適化される他、
if(a!=1){ ～ }をa-=1;if(a){a+=1; ～}と書けるなど
意外と便利である。
なお、実装上は__overflow__というマクロが定義される
形となる。
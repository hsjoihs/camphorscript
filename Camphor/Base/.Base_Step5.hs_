{-# LANGUAGE NoMonomorphismRestriction, FlexibleContexts , NoImplicitPrelude #-}
{-# OPTIONS -Wall -fno-warn-unused-do-bind  -fno-warn-unused-imports #-}
{- memory allocation -}
module Camphor.Base.Base_Step5
(step5,To5
) where

import Camphor.SafePrelude 
import Camphor.Global.Synonyms
import Camphor.Base.NL_parser
import Text.Parsec hiding(token)
import Camphor.Transformer

type To5 = Bool

step5 :: Stream s Identity Char => To5 -> FilePath -> s -> Either ParseError Txt
step5 to5 file str = convert5 to5 <$> parse parserNL' (file ++ "--step5") str

convert5 :: To5 -> [Chunk] -> String
convert5 to5 x = let{x2 = if to5 then simplify x else x} in convert5' x2 ()

simplify :: [Chunk] -> [Chunk]
simplify [] = []
-- simplify (A(INC,num):A(INC,num2):xs) = A(INC,num+num2):simplify xs
-- simplify (A(DEC,num):A(DEC,num2):xs) = A(DEC,num+num2):simplify xs
-- simplify (A(INC,num):A(DEC,num2):xs) 
 -- | num > num2  = A(INC,num-num2):simplify xs
 -- | num == num2 =                 simplify xs -- gone
 -- | num < num2  = A(DEC,num2-num):simplify xs 
-- simplify (x@(A(DEC,_)):y@(A(INC,_)):xs) = simplify $ y:x:xs
simplify (x:xs) = x: simplify xs



convert5' :: [Chunk] -> () -> String
convert5' = map2 c5

map2 :: (a -> StateT n Identity [b]) -> [a] -> n -> [b]
map2 f xs = evalState $ concat <$> mapM f xs

c5 :: Chunk -> StateT () Identity String
c5 (INC  num) = return $ "inc " ++ showNum num ++ ";"
c5 (DEC  num) = return $ "dec " ++ showNum num ++ ";"
c5 (ASR  num) = return $ "assert_zero" ++ showNum num ++ ";"
c5  LOOP      = return $ "loop;"
c5  POOL      = return $ "pool;"
c5  IN        = return   "_input;"
c5  OUT       = return   "output;"
c5 (NUL  sp)  = return   sp
c5 (MOV  num) = return $ "mov " ++ showNum num ++ ";"
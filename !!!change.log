To do
Step7のエラーメッセージ改良
仕様書のような何かを書き始めたい
ロゴ(Git的な)欲しい
行数ズレ解消したい
高度な構文欲しい
エラー検出強力に(関数宣言 No checkはいかん)
GUIラッパ
ccsrcとの統合
warning機能の搭載(WriterTかな?)
zero-checkerといろんな最適化とメモリ位置固定pragma 
GPL付加
Text化
汎用性を上げるためautotestの外部呼び出し以外をHaskell化など
明示再帰が気になるので何とかfoldrに出来ないものか
オプション無しだと-C48で行うのを変更
BF interpreterを自分でも書いてautotestの対象としたい


ver 0.6.26  15:56 2014/08/11 (月)
--課題--
構文強化を終わらせよう
今のうちにエラー連番機構を作っておきたい気もする -- 6:49 2014/08/11 (月)

--構文強化part10--
newSC(1|2)書こうとしてたら周りがスパゲッティだったので一部の関数チェーンを合体 -- 7:17 2014/08/11 (月)
一応体裁は整えたが細かいところが足りない -- 7:27 2014/08/11 (月)
ということで細かい実装を考えていこう
例えば、replacer2で今()を渡しているところにMaybe Ident2を渡し、
そこにblock引数を渡す。
普通の関数呼び出しの時にはNothingを流すだけ
例えばif(~c){b-=1;}だったら、
定義はsyntax if(~char& a){block;}{while(a){clear(a);block;}}なので、
まずreplacerにcとwhile(a){clear(a);block;}を渡し、argとしてJust blockを流す
そして帰ってきたwhile(c){while(c){c-=1;}block;}とblockとb-=1を
blockInsertとかいう関数に渡し、blockをb-=1に置換
すると見事にwhile(c){while(c){c-=1;}b-=1;}という期待通りの結果となる
あとはこれを実装するだけだ -- 8:46 2014/08/11 (月) 
whileの例外規定は…パターンマッチで組み込めばいいか -- 8:54 2014/08/11 (月) 

--構文強化part11--
さて実装です
体裁をもう少し整えた -- 10:00 2014/08/11 (月)
Instanceを得てReplTableまでは出来た -- 10:56 2014/08/11 (月)
↑ちなみに休んでたのではない
ちょっと面倒だったのでwhileだけパターンマッチしてautotestかけよう
autotesterr通す -- 11:06 2014/08/11 (月)
autotest通す -- 11:08 2014/08/11 (月)

--構文強化part12--
とはいえまだPartial残ってるし、verUpにはまだ早い -- 11:09 2014/08/11 (月)
ということでpart10に書いた実装のreplacer部分までは書けた -- 11:25 2014/08/11 (月)
さて、次はblockInsert…
あれ？
{b-=1;}はどこだ？ -- 11:26 2014/08/11 (月)

--構文強化part13--
ということでblockを引数に入れた -- 12:00 2014/08/11 (月)
でもwhileが大丈夫か不安なのでtestのお時間
autotest通す -- 12:48 2014/08/11 (月)
autotesterr通す -- 13:00 2014/08/11 (月)
さて残りの処理を書いていこう -- 13:01 2014/08/11 (月)
replacerのJust Ident2の対応と、blockInsertだ
まずreplacerのJust Ident2…と思ったらそもそも変数単独文をセミコロンには変えていなかったことが判明
(定数単独文は空文になるけど) -- 13:11 2014/08/11 (月)
よって残るはblockInsert -- 13:11 2014/08/11 (月)
多分書けた -- 13:33 2014/08/11 (月)
autotesterr通す -- 13:36 2014/08/11 (月)
autotest通す -- 13:39 2014/08/11 (月)

--構文強化part14--
いよいよ運命の「テストファイル作成」 -- 13:41 2014/08/11 (月)
まずSYNTAXをパースしておらずIdent "syntax"になっていたのを修正 -- 13:51 2014/08/11 (月)
そうしたら'identifier "block" is not defined'が出た
…あーそうでしたはい -- 13:53 2014/08/11 (月)
ここでMaybe Ident2が役に立つ -- 13:53 2014/08/11 (月)
…役立たない。場所が離れすぎてる。 -- 14:15 2014/08/11 (月)
よーし予定通りblockを予約語にしよう -- 14:15 2014/08/11 (月)
でも治らない
原因はwhileにおいてconvert2_3を呼んでること -- 14:37 2014/08/11 (月)
ちなみにただのブロックの場合は問題ない
…はい察した -- 14:45 2014/08/11 (月)
未実装踏んでました -- 14:45 2014/08/11 (月)
syntax内でsyntax呼んでたからバグったわけです -- 14:46 2014/08/11 (月)
バグ発生箇所を特定 -- 14:54 2014/08/11 (月)
…いや、ここが原因とは限らないぞ？ -- 15:03 2014/08/11 (月)
blockInsert'自体は呼ばれているがSynBlockでは呼ばれてない -- 15:16 2014/08/11 (月)
Debug.Trace使ったところ原因把握 -- 15:28 2014/08/11 (月)
SynCall1のSentを再帰的に呼んでいない -- 15:30 2014/08/11 (月)
はいお察し -- 15:30 2014/08/11 (月)
直した -- 15:47 2014/08/11 (月)
autotest通す -- 15:53 2014/08/11 (月)
autotesterr通す -- 15:56 2014/08/11 (月)
時間が時間なのでverUp


ver 0.6.25  16:51 2014/08/10 (日)
--課題--
構文強化を行おう
USINGにおいてassert_zeroを出すようにしたい(最適化のため)
今のうちにエラー連番機構を作っておきたい気もする
え、前回と同じ？何のこと？ -- 6:52 2014/08/10 (日)

--構文強化part6--
syntaxの方は一応前回書いたので、今回はcallだったり実装だったりやっていきたい -- 6:58 2014/08/10 (日)
callのパーサは既存のがあるから上書きすればいいはず -- 7:02 2014/08/10 (日)
…と思ったがその上書きが面倒 -- 7:20 2014/08/10 (日)
SynCall1はできた -- 7:23 2014/08/10 (日)
特に理由もなくautotesterrを通す -- 7:25 2014/08/10 (日)
一応whileの互換性をみるためautotesterrを通す -- 7:28 2014/08/10 (日)
まあ名前変えただけだし通って当然だよね -- 7:29 2014/08/10 (日)

--構文強化part7--
さてSynCall2を作る前にSyntax1の実装を書かねば
VFInfoの型変更 -- 7:58 2014/08/10 (日)
そして溢れるエラー -- 7:59 2014/08/10 (日)
VFInfoはprivateとされていたがそもそもpublicじゃないとおかしい型だった -- 8:01 2014/08/10 (日)
よって改めてpublicにして戦闘突入 -- 8:03 2014/08/10 (日)
戻ってきたので戦闘突入 -- 9:10 2014/08/10 (日)
…さて、それ以前に、そもそも[VFInstance]と[SyntaxInstance]って、
果たして共存不能だろうか。(反語）
不能にしてもいいけどする必要が無いよね -- 9:16 2014/08/10 (日)
なんかの役に立つかもしれない -- 9:16 2014/08/10 (日)
直して敵を排除 -- 9:32 2014/08/10 (日)
取りあえずSyntax1の実装だけ行った -- 9:44 2014/08/10 (日)
autotest通す -- 9:47 2014/08/10 (日)
autotesterr通す -- 9:49 2014/08/10 (日)
warning残ってるしまだverUpには早い

--assert_zeroのお話--
USINGをassert_zeroにしていこう -- 9:53 2014/08/10 (日)
これはintraStepではなくinterStepなので面倒だ -- 9:57 2014/08/10 (日)
具体的には、Base_Step4はassert_zeroに対応していない -- 9:57 2014/08/10 (日)
ということで対応させよう -- 10:06 2014/08/10 (日)
戻ってきて対応させた -- 12:18 2014/08/10 (日)
USINGをassert_zeroにしたはず -- 12:22 2014/08/10 (日)
autotesterr通す -- 12:25 2014/08/10 (日)
assert_zero足したのでautotestは通らないはず -- 12:26 2014/08/10 (日)
案の定通らない -- 12:28 2014/08/10 (日)
まずはHCCSを直す -- 12:39 2014/08/10 (日)
そうすると案の定CCSに波及 -- 12:41 2014/08/10 (日)
直す -- 12:48 2014/08/10 (日)
autotest通る -- 12:50 2014/08/10 (日)
warning残ってるしまだverUpには早い -- 12:51 2014/08/10 (日)

--構文強化part8--
さてwarningを消していきましょう
現時点で残っているのは
・NewのnewS2
・Replacer2のR_SynCall2
・Base_Step2のSynCall2
あとSynCall1の置き換え処理もやってないはず -- 14:51 2014/08/10 (日)
NewのnewS2を実装 -- 15:46 2014/08/10 (日)
理由もなくautotesterr通す -- 15:49 2014/08/10 (日)
理由もなくautotest通…らない…だと？ -- 15:53 2014/08/10 (日)

--assert_zeroについてpart2--
バグ解明。deleteの時のコードをコピペしてた。
deleteは同一スコープである必要があるが、assert_zeroはその必要がない。
そこを考えていなかったのが原因。 -- 16:00 2014/08/10 (日)
直してautotest通す -- 16:06 2014/08/10 (日)
autotesterr通す -- 16:08 2014/08/10 (日)

--構文強化part9--
関数内でSyntaxが宣言出来ないようにした -- 16:39 2014/08/10 (日)
そろそろverUpしたいので取りあえずFIXMEでwarningを封じ込める -- 16:42 2014/08/10 (日)
Base_Step2消えた -- 16:42 2014/08/10 (日)
Replacer2消えた -- 16:46 2014/08/10 (日)
autotesterr通す -- 16:48 2014/08/10 (日)
autotest通す -- 16:51 2014/08/10 (日)
疲れたのでverUp -- 16:51 2014/08/10 (日)



ver 0.6.24  23:09 2014/08/09 (土)
--課題--
構文強化を行おう
USINGにおいてassert_zeroを出すようにしたい(最適化のため)
今のうちにエラー連番機構を作っておきたい気もする -- 7:55 2014/08/09 (土)

--構文強化part3--
blockを予約語にするのはやめよう -- 8:24 2014/08/09 (土)
マクロはマクロらしく潔く『変数』を使うべきだ -- 8:58 2014/08/09 (土)

--module--
各ファイルに散らばってたimportをSafePreludeにまとめた -- 9:55 2014/08/09 (土)
SafePreludeは部分関数を排除するのみならず、
Preludeに入っていない便利な関数を提供する場としても使っている -- 9:58 2014/08/09 (土)

--構文強化part4--
そう言えば、syntax～はともかく、if(a)のところはfunc_callに依存していたはず
しかも今回if(~a)ってのをサポートする予定
よってfunc_callと並んでsyntax_call2というのを作ろう
…と思ったら既にfunc_call_with_blockってのがある
そこを上書きすればOKかもね -- 10:28 2014/08/09 (土)
#型リスト的な#の以外は実装 -- 10:56 2014/08/09 (土)

--prettify--
前から気になっていたSepList(a,xs)をSepList a xsに修正 -- 11:11 2014/08/09 (土)
ちょっとSepList明示的に使いすぎてませんかねぇ -- 11:11 2014/08/09 (土)
ということでSepListをモナドにしようとするもモナド則の証明が面倒 -- 11:58 2014/08/09 (土)
束縛が多すぎると面倒なので関数を分離して再挑戦 -- 12:59 2014/08/09 (土)
結果、48行かかって証明完了 -- 16:33 2014/08/09 (土)
よって晴れてSepListはモナドになったのでFunctorとApplicativeを作って完了 -- 16:36 2014/08/09 (土)
SepList c []をreturn cに変更 -- 22:35 2014/08/09 (土)

--構文強化part5--
取りあえずsyntax側をサポート
サポートと言ってもガン無視してるだけだけど -- 23:04 2014/08/09 (土)
autotesterr通す -- 23:06 2014/08/09 (土)
autotest通す -- 23:09 2014/08/09 (土)
切りが悪いけどここでverUp -- 23:09 2014/08/09 (土)




ver 0.6.23  22:49 2014/08/08 (金)
--課題--
エラーに連番振ろうと思ったけど面倒になったのでエラー連番.txtに隔離し、構文強化を行おう
変則変数宣言も作ろうかな

--変則変数宣言--
vardef = "char" , [singledef, ","] , singledef , ";"
singledef = ident | ident , "=", [ident , "="] , num
って感じでやっていこう -- 10:51 2014/08/07 (木)
singledef書けたけどパーサの戻り値をいじる必要あり -- 11:20 2014/08/07 (木)
いじった -- 14:44 2014/08/07 (木)
多分書けた -- 15:06 2014/08/07 (木)
autotest通った -- 15:10 2014/08/07 (木)
autotesterrも通った -- 15:12 2014/08/07 (木)
この構文をテストするサンプルを作ろう -- 15:14 2014/08/07 (木)
作ってautotestも通った -- 15:26 2014/08/07 (木)

--構文強化--
syntax = "syntax", ident, "(", #型リスト的な#, ")", "{", ident, (";", "}" | "}"),
 "{", 文, "}"
blockを予約語にしようかな -- 16:54 2014/08/08 (金)
例:
syntax if(~char&a){block;}{while(a){while(a){a-=1;}block;}}
syntax if(char&a){block}{char b; b+=a;if(~b){block;}}

--自動セミコロン挿入--
}の前にはセミコロンを自動で挿入するように(データ構造変更) -- 17:10 2014/08/08 (金)
そして溢れるfailure -- 22:34 2014/08/08 (金)
空文を空文字列に置換するように。互換？知らん。 -- 22:34 2014/08/08 (金)
autotes(t|terr)通す -- 22:37 2014/08/08 (金)

--構文強化part2--
"syntax"を予約語に -- 22:43 2014/08/08 (金)
autotesterr通す -- 22:46 2014/08/08 (金)
autotest通す -- 22:48 2014/08/08 (金)
微妙だけどここで切ってverUp -- 22:48 2014/08/08 (金)



ver 0.6.22 13:46 2014/08/03 (日)
--課題--
xHello,xEcho,xtoLowerなどをCamphorScriptで書いてautotestに奉納
可読性も上げる(コメント追加も)
演算子で(/ *)とか

--Tuple--
tupleを一般化する型クラス作成
SafePreludeいじったので面倒だった -- 22:51 2014/08/01 (金)

--Base_Step3_I--
State化出来た -- 23:13 2014/08/01 (金)

--BF->CS--
まずxHelloから
CCS_revを取ってきて加工しよう -- 0:02 2014/08/02 (土)
うーむ最適化が上手で面倒だ、別のにしよう -- 0:12 2014/08/02 (土)
xEchoできたけどちょっと簡単すぎるかも -- 0:16 2014/08/02 (土)
xtoLower:うん、ここからが本番 -- 0:17 2014/08/02 (土)
あーコーディングスタイルが合わない 
仕方がない、新たにxtoLower2とするか -- 0:20 2014/08/02 (土)
はいバグった -- 0:43 2014/08/02 (土)

--FIXME排除--
暇なのでFIXMEの排除でもやっとこう -- 7:34 2014/08/03 (日)
まずはbreakByから。
問題発生地点はminimumsBy.ここをいじる。 -- 7:37 2014/08/03 (日)
あれ、minimumsByの宣言ってどこだ。
あ、NonEmptyか -- 7:38 2014/08/03 (日)
他のファイルでは一切使われていないのでNew.hsに移動 -- 7:40 2014/08/03 (日)
他にも色々New.hsに持ってきたが、汚くなるので一時的にファイル分離 -- 7:47 2014/08/03 (日)
論理をいじったので一旦autotest
通った -- 7:56 2014/08/03 (日)
うーむ再帰関数が複雑に呼ばれ合ってて面倒 -- 7:59 2014/08/03 (日)
要はminimumsByとbreakByをくっつければいいのだが -- 8:02 2014/08/03 (日)
まずcontradictionから処理 -- 8:10 2014/08/03 (日)
contradiction統合 -- 8:23 2014/08/03 (日)
…そもそも「最小値を探す」→「最小値で切る」という考え方が命令的な気がする -- 8:48 2014/08/03 (日)
「最小値を探しながら切る」という別の関数を作ればいい -- 8:50 2014/08/03 (日)
contradictionは現状でOKでしょう -- 8:53 2014/08/03 (日)
ということでbreakBy(Fir|La)stMinimumという関数のもとエラーを抜いた -- 9:06 2014/08/03 (日)
あとは実装するのみ -- 9:06 2014/08/03 (日)
さて戻ってきたので実装 -- 10:34 2014/08/03 (日)
FixityだとCmp出来るけどOperじゃ出来ない -- 10:43 2014/08/03 (日)
そうだ、cmpにM.Mapを読ませよう -- 10:43 2014/08/03 (日)
…そうか、Eitherか…… -- 10:56 2014/08/03 (日)
仕方がないのでmonadicに(part1) -- 11:06 2014/08/03 (日)
Lastはもう面倒だからreverseしてFirst1で処理しよう -- 11:11 2014/08/03 (日)
よしコンパイル通った -- 11:14 2014/08/03 (日)
よしワーニング消えた -- 11:15 2014/08/03 (日)
よしautotest通った
でもautotestでここらへんの処理入れてないからtestになっているのかどうか -- 11:21 2014/08/03 (日)
autotesterrも通った -- 11:24 2014/08/03 (日)




ver 0.6.21 18:39 2014/08/01 (金)
--課題--
xCopyVar2を通す
/の入った演算子を確認
演算子で(/ *)とかを定義してバグが出るか確認 
サンプル増量 -- 16:40 2014/07/31 (木)

--xCopyVar2--
そもそもCollisionTableって回すものなのだろうか -- 7:58 2014/08/01 (金)
ということで毎回クリアしてみた -- 7:59 2014/08/01 (金)
…既存のコードは壊れないようだ -- 8:02 2014/08/01 (金)
xCopyVar2を入れてみる -- 8:02 2014/08/01 (金)
成功ｷﾀ━━━━(ﾟ∀ﾟ)━━━━!! -- 8:04 2014/08/01 (金)
ということで原因解明
古いCollisionTableで変数が上書きされてしまうのが原因 -- 8:05 2014/08/01 (金)
よってCollisionTableをNonEmptyにする必要がなくなった -- 8:06 2014/08/01 (金)
NonEmpty抜いた -- 8:14 2014/08/01 (金)

--サンプル増量--
さてサンプル増やそう -- 8:24 2014/08/01 (金)
…と思ったけど-C33で/*# LINE #*/を消してインデントを揃えたい -- 8:48 2014/08/01 (金)
今のままじゃ面倒なのでね -- 8:49 2014/08/01 (金)
ちょうどいいことに今-C33はもぬけの殻 -- 13:28 2014/08/01 (金)
インデント出来た -- 16:28 2014/08/01 (金)
LINEまあ出来た -- 16:41 2014/08/01 (金)

--(/)演算子の確認--
まずはfixdeclのコメントアウトを外す
autotestを通すと当然エラー -- 17:04 2014/08/01 (金)
-Eを対策 -- 17:04 2014/08/01 (金)
-C22も対策 -- 17:10 2014/08/01 (金)
(/ *)？知らん。後回し。

--サンプル増量(part2)--
-C33を登録、通す -- 17:35 2014/08/01 (金)
BF側とリンクさせたいがxAtoIとか名前が被る -- 18:02 2014/08/01 (金)
…両方一致してました、というか一致するように昔書いたはず -- 18:05 2014/08/01 (金)
通す -- 18:08 2014/08/01 (金)
あとCSのxIsNumber_oとBFのxIsNumberも一致 -- 18:10 2014/08/01 (金)
面倒なのでCSのxIsNumber_oとxIsNumberをそれぞれxIsNumberとxIsNumber_uに変更 -- 18:12 2014/08/01 (金)
通す -- 18:15 2014/08/01 (金)
残りに衝突無し、生成する。 -- 18:20 2014/08/01 (金)
面倒なのでautotestに作らせた -- 18:27 2014/08/01 (金)
通した -- 18:34 2014/08/01 (金)